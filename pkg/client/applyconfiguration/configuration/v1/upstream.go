// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

// UpstreamApplyConfiguration represents a declarative configuration of the Upstream type for use
// with apply.
//
// Upstream defines an upstream.
type UpstreamApplyConfiguration struct {
	// The name of the upstream. Must be a valid DNS label as defined in RFC 1035. For example, hello and upstream-123 are valid. The name must be unique among all upstreams of the resource.
	Name *string `json:"name,omitempty"`
	// The name of a service. If the Service belongs to a different namespace than the VirtualServer or VirtualServerRoute, you need to include the namespace. For example, tea-namespace/tea. If the service doesn’t exist, NGINX will assume the service has zero endpoints and return a 502 response for requests for this upstream. For NGINX Plus only, services of type ExternalName are also supported in the same namespace.
	Service *string `json:"service,omitempty"`
	// Selects the pods within the service using label keys and values. By default, all pods of the service are selected. Note: the specified labels are expected to be present in the pods when they are created. If the pod labels are updated, NGINX Ingress Controller will not see that change until the number of the pods is changed.
	Subselector map[string]string `json:"subselector,omitempty"`
	// The port of the service. If the service doesn’t define that port, NGINX will assume the service has zero endpoints and return a 502 response for requests for this upstream. The port must fall into the range 1..65535.
	Port *uint16 `json:"port,omitempty"`
	// The load balancing method. To use the round-robin method, specify round_robin. The default is specified in the lb-method ConfigMap key.
	LBMethod *string `json:"lb-method,omitempty"`
	// The time during which the specified number of unsuccessful attempts to communicate with an upstream server should happen to consider the server unavailable. The default is set in the fail-timeout ConfigMap key.
	FailTimeout *string `json:"fail-timeout,omitempty"`
	// The number of unsuccessful attempts to communicate with an upstream server that should happen in the duration set by the fail-timeout to consider the server unavailable. The default is set in the max-fails ConfigMap key.
	MaxFails *int `json:"max-fails,omitempty"`
	// The maximum number of simultaneous active connections to an upstream server. By default there is no limit. Note: if keepalive connections are enabled, the total number of active and idle keepalive connections to an upstream server may exceed the max_conns value.
	MaxConns *int `json:"max-conns,omitempty"`
	// Configures the cache for connections to upstream servers. The value 0 disables the cache. The default is set in the keepalive ConfigMap key.
	Keepalive *int `json:"keepalive,omitempty"`
	// The timeout for establishing a connection with an upstream server. The default is specified in the proxy-connect-timeout ConfigMap key.
	ProxyConnectTimeout *string `json:"connect-timeout,omitempty"`
	// The timeout for reading a response from an upstream server. The default is specified in the proxy-read-timeout ConfigMap key.
	ProxyReadTimeout *string `json:"read-timeout,omitempty"`
	// The timeout for transmitting a request to an upstream server. The default is specified in the proxy-send-timeout ConfigMap key.
	ProxySendTimeout *string `json:"send-timeout,omitempty"`
	// Specifies in which cases a request should be passed to the next upstream server. The default is error timeout.
	ProxyNextUpstream *string `json:"next-upstream,omitempty"`
	// The time during which a request can be passed to the next upstream server. The 0 value turns off the time limit. The default is 0.
	ProxyNextUpstreamTimeout *string `json:"next-upstream-timeout,omitempty"`
	// The number of possible tries for passing a request to the next upstream server. The 0 value turns off this limit. The default is 0.
	ProxyNextUpstreamTries *int `json:"next-upstream-tries,omitempty"`
	// Enables buffering of responses from the upstream server.  The default is set in the proxy-buffering ConfigMap key.
	ProxyBuffering *bool `json:"buffering,omitempty"`
	// Configures the buffers used for reading a response from the upstream server for a single connection.
	ProxyBuffers *UpstreamBuffersApplyConfiguration `json:"buffers,omitempty"`
	// Sets the size of the buffer used for reading the first part of a response received from the upstream server. The default is set in the proxy-buffer-size ConfigMap key.
	ProxyBufferSize *string `json:"buffer-size,omitempty"`
	// Sets the size of the buffers used for reading a response from the upstream server when the proxy_buffering is enabled. The default is set in the proxy-busy-buffers-size ConfigMap key.'
	ProxyBusyBuffersSize *string `json:"busy-buffers-size,omitempty"`
	// Sets the maximum allowed size of the client request body. The default is set in the client-max-body-size ConfigMap key.
	ClientMaxBodySize *string `json:"client-max-body-size,omitempty"`
	// ClientBodyBufferSize sets the size of the buffer used for reading the client request body. Must be specified as a number followed by:
	// 'k' for kilobytes or 'm' for megabytes.
	// Examples: "10m" or "512k".
	ClientBodyBufferSize *string `json:"client-body-buffer-size,omitempty"`
	// The TLS configuration for the Upstream.
	TLS *UpstreamTLSApplyConfiguration `json:"tls,omitempty"`
	// The health check configuration for the Upstream. Note: this feature is supported only in NGINX Plus.
	HealthCheck *HealthCheckApplyConfiguration `json:"healthCheck,omitempty"`
	// The slow start allows an upstream server to gradually recover its weight from 0 to its nominal value after it has been recovered or became available or when the server becomes available after a period of time it was considered unavailable. By default, the slow start is disabled. Note: The parameter cannot be used along with the random, hash or ip_hash load balancing methods and will be ignored.
	SlowStart *string `json:"slow-start,omitempty"`
	// Configures a queue for an upstream. A client request will be placed into the queue if an upstream server cannot be selected immediately while processing the request. By default, no queue is configured. Note: this feature is supported only in NGINX Plus.
	Queue *UpstreamQueueApplyConfiguration `json:"queue,omitempty"`
	// The SessionCookie field configures session persistence which allows requests from the same client to be passed to the same upstream server. The information about the designated upstream server is passed in a session cookie generated by NGINX Plus.
	SessionCookie *SessionCookieApplyConfiguration `json:"sessionCookie,omitempty"`
	// Enables using the Cluster IP and port of the service instead of the default behavior of using the IP and port of the pods. When this field is enabled, the fields that configure NGINX behavior related to multiple upstream servers (like lb-method and next-upstream) will have no effect, as NGINX Ingress Controller will configure NGINX with only one upstream server that will match the service Cluster IP.
	UseClusterIP *bool `json:"use-cluster-ip,omitempty"`
	// Allows proxying requests with NTLM Authentication. In order for NTLM authentication to work, it is necessary to enable keepalive connections to upstream servers using the keepalive field. Note: this feature is supported only in NGINX Plus.
	NTLM *bool `json:"ntlm,omitempty"`
	// The type of the upstream. Supported values are http and grpc. The default is http. For gRPC, it is necessary to enable HTTP/2 in the ConfigMap and configure TLS termination in the VirtualServer.
	Type *string `json:"type,omitempty"`
	// The name of the backup service of type ExternalName. This will be used when the primary servers are unavailable. Note: The parameter cannot be used along with the random, hash or ip_hash load balancing methods.
	Backup *string `json:"backup,omitempty"`
	// The port of the backup service. The backup port is required if the backup service name is provided. The port must fall into the range 1..65535.
	BackupPort *uint16 `json:"backupPort,omitempty"`
}

// UpstreamApplyConfiguration constructs a declarative configuration of the Upstream type for use with
// apply.
func Upstream() *UpstreamApplyConfiguration {
	return &UpstreamApplyConfiguration{}
}

// WithName sets the Name field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Name field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithName(value string) *UpstreamApplyConfiguration {
	b.Name = &value
	return b
}

// WithService sets the Service field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Service field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithService(value string) *UpstreamApplyConfiguration {
	b.Service = &value
	return b
}

// WithSubselector puts the entries into the Subselector field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Subselector field,
// overwriting an existing map entries in Subselector field with the same key.
func (b *UpstreamApplyConfiguration) WithSubselector(entries map[string]string) *UpstreamApplyConfiguration {
	if b.Subselector == nil && len(entries) > 0 {
		b.Subselector = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.Subselector[k] = v
	}
	return b
}

// WithPort sets the Port field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Port field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithPort(value uint16) *UpstreamApplyConfiguration {
	b.Port = &value
	return b
}

// WithLBMethod sets the LBMethod field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the LBMethod field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithLBMethod(value string) *UpstreamApplyConfiguration {
	b.LBMethod = &value
	return b
}

// WithFailTimeout sets the FailTimeout field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the FailTimeout field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithFailTimeout(value string) *UpstreamApplyConfiguration {
	b.FailTimeout = &value
	return b
}

// WithMaxFails sets the MaxFails field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the MaxFails field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithMaxFails(value int) *UpstreamApplyConfiguration {
	b.MaxFails = &value
	return b
}

// WithMaxConns sets the MaxConns field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the MaxConns field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithMaxConns(value int) *UpstreamApplyConfiguration {
	b.MaxConns = &value
	return b
}

// WithKeepalive sets the Keepalive field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Keepalive field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithKeepalive(value int) *UpstreamApplyConfiguration {
	b.Keepalive = &value
	return b
}

// WithProxyConnectTimeout sets the ProxyConnectTimeout field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ProxyConnectTimeout field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithProxyConnectTimeout(value string) *UpstreamApplyConfiguration {
	b.ProxyConnectTimeout = &value
	return b
}

// WithProxyReadTimeout sets the ProxyReadTimeout field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ProxyReadTimeout field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithProxyReadTimeout(value string) *UpstreamApplyConfiguration {
	b.ProxyReadTimeout = &value
	return b
}

// WithProxySendTimeout sets the ProxySendTimeout field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ProxySendTimeout field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithProxySendTimeout(value string) *UpstreamApplyConfiguration {
	b.ProxySendTimeout = &value
	return b
}

// WithProxyNextUpstream sets the ProxyNextUpstream field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ProxyNextUpstream field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithProxyNextUpstream(value string) *UpstreamApplyConfiguration {
	b.ProxyNextUpstream = &value
	return b
}

// WithProxyNextUpstreamTimeout sets the ProxyNextUpstreamTimeout field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ProxyNextUpstreamTimeout field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithProxyNextUpstreamTimeout(value string) *UpstreamApplyConfiguration {
	b.ProxyNextUpstreamTimeout = &value
	return b
}

// WithProxyNextUpstreamTries sets the ProxyNextUpstreamTries field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ProxyNextUpstreamTries field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithProxyNextUpstreamTries(value int) *UpstreamApplyConfiguration {
	b.ProxyNextUpstreamTries = &value
	return b
}

// WithProxyBuffering sets the ProxyBuffering field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ProxyBuffering field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithProxyBuffering(value bool) *UpstreamApplyConfiguration {
	b.ProxyBuffering = &value
	return b
}

// WithProxyBuffers sets the ProxyBuffers field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ProxyBuffers field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithProxyBuffers(value *UpstreamBuffersApplyConfiguration) *UpstreamApplyConfiguration {
	b.ProxyBuffers = value
	return b
}

// WithProxyBufferSize sets the ProxyBufferSize field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ProxyBufferSize field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithProxyBufferSize(value string) *UpstreamApplyConfiguration {
	b.ProxyBufferSize = &value
	return b
}

// WithProxyBusyBuffersSize sets the ProxyBusyBuffersSize field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ProxyBusyBuffersSize field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithProxyBusyBuffersSize(value string) *UpstreamApplyConfiguration {
	b.ProxyBusyBuffersSize = &value
	return b
}

// WithClientMaxBodySize sets the ClientMaxBodySize field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ClientMaxBodySize field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithClientMaxBodySize(value string) *UpstreamApplyConfiguration {
	b.ClientMaxBodySize = &value
	return b
}

// WithClientBodyBufferSize sets the ClientBodyBufferSize field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ClientBodyBufferSize field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithClientBodyBufferSize(value string) *UpstreamApplyConfiguration {
	b.ClientBodyBufferSize = &value
	return b
}

// WithTLS sets the TLS field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the TLS field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithTLS(value *UpstreamTLSApplyConfiguration) *UpstreamApplyConfiguration {
	b.TLS = value
	return b
}

// WithHealthCheck sets the HealthCheck field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the HealthCheck field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithHealthCheck(value *HealthCheckApplyConfiguration) *UpstreamApplyConfiguration {
	b.HealthCheck = value
	return b
}

// WithSlowStart sets the SlowStart field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the SlowStart field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithSlowStart(value string) *UpstreamApplyConfiguration {
	b.SlowStart = &value
	return b
}

// WithQueue sets the Queue field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Queue field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithQueue(value *UpstreamQueueApplyConfiguration) *UpstreamApplyConfiguration {
	b.Queue = value
	return b
}

// WithSessionCookie sets the SessionCookie field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the SessionCookie field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithSessionCookie(value *SessionCookieApplyConfiguration) *UpstreamApplyConfiguration {
	b.SessionCookie = value
	return b
}

// WithUseClusterIP sets the UseClusterIP field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the UseClusterIP field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithUseClusterIP(value bool) *UpstreamApplyConfiguration {
	b.UseClusterIP = &value
	return b
}

// WithNTLM sets the NTLM field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the NTLM field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithNTLM(value bool) *UpstreamApplyConfiguration {
	b.NTLM = &value
	return b
}

// WithType sets the Type field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Type field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithType(value string) *UpstreamApplyConfiguration {
	b.Type = &value
	return b
}

// WithBackup sets the Backup field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Backup field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithBackup(value string) *UpstreamApplyConfiguration {
	b.Backup = &value
	return b
}

// WithBackupPort sets the BackupPort field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the BackupPort field is set to the value of the last call.
func (b *UpstreamApplyConfiguration) WithBackupPort(value uint16) *UpstreamApplyConfiguration {
	b.BackupPort = &value
	return b
}
